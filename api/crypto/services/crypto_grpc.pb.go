// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: api/crypto/services/crypto.proto

package services

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CryptoClient is the client API for Crypto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoClient interface {
	// Encrypt will encrypt msg and aad using a matching AEAD primitive in kh key handle of a public key
	// returns:
	//              cipherText in []byte
	//              nonce in []byte
	//              error in case of errors during encryption
	// POST /crypto/encrypt
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	// Decrypt will decrypt cipher with aad and given nonce using a matching AEAD primitive in kh key handle of a
	// private key
	// returns:
	//              plainText in []byte
	//              error in case of errors
	// POST /crypto/decrypt
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	// Sign will sign msg using a matching signature primitive in kh key handle of a private key
	// returns:
	//              signature in []byte
	//              error in case of errors
	// POST /crypto/sign
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	// Verify will verify a signature for the given msg using a matching signature primitive in kh key handle of
	// a public key
	// returns:
	//              error in case of errors or nil if signature verification was successful
	// POST /crypto/verify
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	// ComputeMAC computes message authentication code (MAC) for code data
	// using a matching MAC primitive in kh key handle
	// POST /crypto/computeMac
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	ComputeMac(ctx context.Context, in *ComputeMacRequest, opts ...grpc.CallOption) (*ComputeMacResponse, error)
	// VerifyMAC determines if mac is a correct authentication code (MAC) for data
	// using a matching MAC primitive in kh key handle and returns nil if so, otherwise it returns an error.
	// POST /crypto/verifyMac
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	VerifyMac(ctx context.Context, in *VerifyMacRequest, opts ...grpc.CallOption) (*VerifyMacResponse, error)
	// WrapKey will execute key wrapping of cek using apu, apv and recipient public key 'recPubKey'.
	// 'opts' allows setting the optional sender key handle using WithSender() option and the an authentication tag
	// using WithTag() option. These allow ECDH-1PU key unwrapping (aka Authcrypt).
	// The absence of these options uses ECDH-ES key wrapping (aka Anoncrypt). Another option that can
	// be used is WithXC20PKW() to instruct the WrapKey to use XC20P key wrapping instead of the default A256GCM.
	// returns:
	//              RecipientWrappedKey containing the wrapped cek value
	//              error in case of errors
	// POST /crypto/wrapKey
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error)
	// UnwrapKey unwraps a key in recWK using recipient private key kh.
	// 'opts' allows setting the optional sender key handle using WithSender() option and the an authentication tag
	// using WithTag() option. These allow ECDH-1PU key unwrapping (aka Authcrypt).
	// The absence of these options uses ECDH-ES key unwrapping (aka Anoncrypt). There is no need to
	// use WithXC20PKW() for UnwrapKey since the function will use the wrapping algorithm based on recWK.Alg.
	// returns:
	//              unwrapped key in raw bytes
	//              error in case of errors
	// POST /crypto/unwrapKey
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error)
	// SignMulti will create a signature of messages using a matching signing primitive found in kh key handle of a
	// private key.
	// returns:
	//              signature in []byte
	//              error in case of errors
	// POST /crypto/signMulti
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	SignMulti(ctx context.Context, in *SignMultiRequest, opts ...grpc.CallOption) (*SignMultiResponse, error)
	// VerifyMulti will verify a signature of messages using a matching signing primitive found in kh key handle of a
	// public key.
	// returns:
	//              error in case of errors or nil if signature verification was successful
	// POST /crypto/verifyMulti
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	VerifyMulti(ctx context.Context, in *VerifyMultiRequest, opts ...grpc.CallOption) (*VerifyMultiResponse, error)
	// VerifyProof will verify a signature proof (generated e.g. by Verifier's DeriveProof() call) for revealedMessages
	// using a matching signing primitive found in kh key handle of a public key.
	// returns:
	//              error in case of errors or nil if signature proof verification was successful
	// POST /crypto/verifyProof
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	VerifyProof(ctx context.Context, in *VerifyProofRequest, opts ...grpc.CallOption) (*VerifyProofResponse, error)
	// DeriveProof will create a signature proof for a list of revealed messages using BBS signature (can be built using
	// a Signer's SignMulti() call) and a matching signing primitive found in kh key handle of a public key.
	// returns:
	//              signature proof in []byte
	//              error in case of errors
	// POST /crypto/deriveProof
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	DeriveProof(ctx context.Context, in *DeriveProofRequest, opts ...grpc.CallOption) (*DeriveProofResponse, error)
}

type cryptoClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoClient(cc grpc.ClientConnInterface) CryptoClient {
	return &cryptoClient{cc}
}

func (c *cryptoClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/encrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/decrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) ComputeMac(ctx context.Context, in *ComputeMacRequest, opts ...grpc.CallOption) (*ComputeMacResponse, error) {
	out := new(ComputeMacResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/computeMac", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyMac(ctx context.Context, in *VerifyMacRequest, opts ...grpc.CallOption) (*VerifyMacResponse, error) {
	out := new(VerifyMacResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/verifyMac", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error) {
	out := new(WrapKeyResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/wrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error) {
	out := new(UnwrapKeyResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/unwrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignMulti(ctx context.Context, in *SignMultiRequest, opts ...grpc.CallOption) (*SignMultiResponse, error) {
	out := new(SignMultiResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/signMulti", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyMulti(ctx context.Context, in *VerifyMultiRequest, opts ...grpc.CallOption) (*VerifyMultiResponse, error) {
	out := new(VerifyMultiResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/verifyMulti", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyProof(ctx context.Context, in *VerifyProofRequest, opts ...grpc.CallOption) (*VerifyProofResponse, error) {
	out := new(VerifyProofResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/verifyProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DeriveProof(ctx context.Context, in *DeriveProofRequest, opts ...grpc.CallOption) (*DeriveProofResponse, error) {
	out := new(DeriveProofResponse)
	err := c.cc.Invoke(ctx, "/api.crypto.services.Crypto/deriveProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoServer is the server API for Crypto service.
// All implementations must embed UnimplementedCryptoServer
// for forward compatibility
type CryptoServer interface {
	// Encrypt will encrypt msg and aad using a matching AEAD primitive in kh key handle of a public key
	// returns:
	//              cipherText in []byte
	//              nonce in []byte
	//              error in case of errors during encryption
	// POST /crypto/encrypt
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	// Decrypt will decrypt cipher with aad and given nonce using a matching AEAD primitive in kh key handle of a
	// private key
	// returns:
	//              plainText in []byte
	//              error in case of errors
	// POST /crypto/decrypt
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	// Sign will sign msg using a matching signature primitive in kh key handle of a private key
	// returns:
	//              signature in []byte
	//              error in case of errors
	// POST /crypto/sign
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	// Verify will verify a signature for the given msg using a matching signature primitive in kh key handle of
	// a public key
	// returns:
	//              error in case of errors or nil if signature verification was successful
	// POST /crypto/verify
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	// ComputeMAC computes message authentication code (MAC) for code data
	// using a matching MAC primitive in kh key handle
	// POST /crypto/computeMac
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	ComputeMac(context.Context, *ComputeMacRequest) (*ComputeMacResponse, error)
	// VerifyMAC determines if mac is a correct authentication code (MAC) for data
	// using a matching MAC primitive in kh key handle and returns nil if so, otherwise it returns an error.
	// POST /crypto/verifyMac
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	VerifyMac(context.Context, *VerifyMacRequest) (*VerifyMacResponse, error)
	// WrapKey will execute key wrapping of cek using apu, apv and recipient public key 'recPubKey'.
	// 'opts' allows setting the optional sender key handle using WithSender() option and the an authentication tag
	// using WithTag() option. These allow ECDH-1PU key unwrapping (aka Authcrypt).
	// The absence of these options uses ECDH-ES key wrapping (aka Anoncrypt). Another option that can
	// be used is WithXC20PKW() to instruct the WrapKey to use XC20P key wrapping instead of the default A256GCM.
	// returns:
	//              RecipientWrappedKey containing the wrapped cek value
	//              error in case of errors
	// POST /crypto/wrapKey
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error)
	// UnwrapKey unwraps a key in recWK using recipient private key kh.
	// 'opts' allows setting the optional sender key handle using WithSender() option and the an authentication tag
	// using WithTag() option. These allow ECDH-1PU key unwrapping (aka Authcrypt).
	// The absence of these options uses ECDH-ES key unwrapping (aka Anoncrypt). There is no need to
	// use WithXC20PKW() for UnwrapKey since the function will use the wrapping algorithm based on recWK.Alg.
	// returns:
	//              unwrapped key in raw bytes
	//              error in case of errors
	// POST /crypto/unwrapKey
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error)
	// SignMulti will create a signature of messages using a matching signing primitive found in kh key handle of a
	// private key.
	// returns:
	//              signature in []byte
	//              error in case of errors
	// POST /crypto/signMulti
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	SignMulti(context.Context, *SignMultiRequest) (*SignMultiResponse, error)
	// VerifyMulti will verify a signature of messages using a matching signing primitive found in kh key handle of a
	// public key.
	// returns:
	//              error in case of errors or nil if signature verification was successful
	// POST /crypto/verifyMulti
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	VerifyMulti(context.Context, *VerifyMultiRequest) (*VerifyMultiResponse, error)
	// VerifyProof will verify a signature proof (generated e.g. by Verifier's DeriveProof() call) for revealedMessages
	// using a matching signing primitive found in kh key handle of a public key.
	// returns:
	//              error in case of errors or nil if signature proof verification was successful
	// POST /crypto/verifyProof
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	VerifyProof(context.Context, *VerifyProofRequest) (*VerifyProofResponse, error)
	// DeriveProof will create a signature proof for a list of revealed messages using BBS signature (can be built using
	// a Signer's SignMulti() call) and a matching signing primitive found in kh key handle of a public key.
	// returns:
	//              signature proof in []byte
	//              error in case of errors
	// POST /crypto/deriveProof
	// 200	successfully !
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	DeriveProof(context.Context, *DeriveProofRequest) (*DeriveProofResponse, error)
	mustEmbedUnimplementedCryptoServer()
}

// UnimplementedCryptoServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoServer struct {
}

func (UnimplementedCryptoServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedCryptoServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedCryptoServer) Sign(context.Context, *SignRequest) (*SignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedCryptoServer) Verify(context.Context, *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedCryptoServer) ComputeMac(context.Context, *ComputeMacRequest) (*ComputeMacResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComputeMac not implemented")
}
func (UnimplementedCryptoServer) VerifyMac(context.Context, *VerifyMacRequest) (*VerifyMacResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMac not implemented")
}
func (UnimplementedCryptoServer) WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WrapKey not implemented")
}
func (UnimplementedCryptoServer) UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnwrapKey not implemented")
}
func (UnimplementedCryptoServer) SignMulti(context.Context, *SignMultiRequest) (*SignMultiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMulti not implemented")
}
func (UnimplementedCryptoServer) VerifyMulti(context.Context, *VerifyMultiRequest) (*VerifyMultiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyMulti not implemented")
}
func (UnimplementedCryptoServer) VerifyProof(context.Context, *VerifyProofRequest) (*VerifyProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyProof not implemented")
}
func (UnimplementedCryptoServer) DeriveProof(context.Context, *DeriveProofRequest) (*DeriveProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeriveProof not implemented")
}
func (UnimplementedCryptoServer) mustEmbedUnimplementedCryptoServer() {}

// UnsafeCryptoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoServer will
// result in compilation errors.
type UnsafeCryptoServer interface {
	mustEmbedUnimplementedCryptoServer()
}

func RegisterCryptoServer(s grpc.ServiceRegistrar, srv CryptoServer) {
	s.RegisterService(&Crypto_ServiceDesc, srv)
}

func _Crypto_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/encrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/decrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_ComputeMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeMacRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).ComputeMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/computeMac",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).ComputeMac(ctx, req.(*ComputeMacRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMacRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/verifyMac",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyMac(ctx, req.(*VerifyMacRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/wrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).WrapKey(ctx, req.(*WrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/unwrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).UnwrapKey(ctx, req.(*UnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignMulti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMultiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignMulti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/signMulti",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignMulti(ctx, req.(*SignMultiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyMulti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMultiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyMulti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/verifyMulti",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyMulti(ctx, req.(*VerifyMultiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/verifyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyProof(ctx, req.(*VerifyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DeriveProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeriveProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DeriveProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.crypto.services.Crypto/deriveProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DeriveProof(ctx, req.(*DeriveProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Crypto_ServiceDesc is the grpc.ServiceDesc for Crypto service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Crypto_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.crypto.services.Crypto",
	HandlerType: (*CryptoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "encrypt",
			Handler:    _Crypto_Encrypt_Handler,
		},
		{
			MethodName: "decrypt",
			Handler:    _Crypto_Decrypt_Handler,
		},
		{
			MethodName: "sign",
			Handler:    _Crypto_Sign_Handler,
		},
		{
			MethodName: "verify",
			Handler:    _Crypto_Verify_Handler,
		},
		{
			MethodName: "computeMac",
			Handler:    _Crypto_ComputeMac_Handler,
		},
		{
			MethodName: "verifyMac",
			Handler:    _Crypto_VerifyMac_Handler,
		},
		{
			MethodName: "wrapKey",
			Handler:    _Crypto_WrapKey_Handler,
		},
		{
			MethodName: "unwrapKey",
			Handler:    _Crypto_UnwrapKey_Handler,
		},
		{
			MethodName: "signMulti",
			Handler:    _Crypto_SignMulti_Handler,
		},
		{
			MethodName: "verifyMulti",
			Handler:    _Crypto_VerifyMulti_Handler,
		},
		{
			MethodName: "verifyProof",
			Handler:    _Crypto_VerifyProof_Handler,
		},
		{
			MethodName: "deriveProof",
			Handler:    _Crypto_DeriveProof_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/crypto/services/crypto.proto",
}
