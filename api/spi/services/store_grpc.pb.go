// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: api/spi/services/store.proto

package services

import (
	context "context"
	types "github.com/bhatti/GSSI/api/spi/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// StoreClient is the client API for Store service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StoreClient interface {
	// Verifies a verifiableCredential and returns a verificationResult in the response body.
	// POST /store
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Put(ctx context.Context, in *StorePutRequest, opts ...grpc.CallOption) (*types.Void, error)
	// Get fetches the value associated with the given key.
	// If key cannot be found, then an error wrapping ErrDataNotFound will be returned.
	// If key is empty, then an error will be returned.
	// GET /store/{id}
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	Get(ctx context.Context, in *StoreKeyRequest, opts ...grpc.CallOption) (*StoreGetResponse, error)
	// GetTags fetches all tags associated with the given key.
	// If key cannot be found, then an error wrapping ErrDataNotFound will be returned.
	// If key is empty, then an error will be returned.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// GET /store/{id}
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	GetTags(ctx context.Context, in *StoreKeyRequest, opts ...grpc.CallOption) (*StoreTagsResponse, error)
	// GetBulk fetches the values associated with the given keys.
	// If no data exists under a given key, then a nil []byte is returned for that value. It is not considered an error.
	// Depending on the implementation, this method may be faster than calling Get for each key individually.
	// If any of the given keys are empty, then an error will be returned.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// GET /store/bulk
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	GetBulk(ctx context.Context, in *StoreBulkKeyRequest, opts ...grpc.CallOption) (*StoreBulkGetResponse, error)
	// Query returns all data that satisfies the expression. Basic expression format: TagName:TagValue.
	// If TagValue is not provided, then all data associated with the TagName will be returned, regardless of their
	// tag values.
	// At a minimum, a store implementation must be able to support querying with a single basic expression, but a
	// store implementation may also support a more advanced expression format.
	// Advanced expression format: [Criterion1][Operator][Criterion2][Operator]...[CriterionN]. Square brackets are
	// used here for visual clarity. Omit them from the actual expression string.
	// Each Criterion follows the rules for the basic expression format described above.
	// Each operator must be either "&&" or "||" (without quotes). "&&" indicates an AND operator while "||"
	// indicates an OR operator. The order of operations are ANDs followed by ORs.
	// This method also supports a number of QueryOptions. If none are provided, then defaults will be used.
	// If your store contains a large amount of data, then it's recommended calling Provider.SetStoreConfig at some
	// point before calling this method in order to create indexes which will speed up queries.
	// GET /store
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	Query(ctx context.Context, in *StoreQueryRequest, opts ...grpc.CallOption) (Store_QueryClient, error)
	// Batch performs multiple Put and/or Delete operations in order. The Puts and Deletes here follow the same rules
	// as described in the Put and Delete method documentation. The only exception is if the operation makes use of
	// the PutOptions.IsNewKey optimization, in which case an error wrapping an ErrDuplicateKey may be returned if it's
	// enabled and a key is used that already exists in the database.
	// Depending on the implementation, this method may be faster than repeated Put and/or Delete calls.
	// If any of the given keys are empty, or the operations slice is empty or nil, then an error will be returned.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// POST /store/bulk
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	PutBulk(ctx context.Context, in *StoreBulkPutRequest, opts ...grpc.CallOption) (*types.Void, error)
	// Delete deletes the key + value pair (and all tags) associated with key.
	// If key is empty, then an error will be returned.
	// DELETE /store/{id}
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Delete(ctx context.Context, in *StoreKeyRequest, opts ...grpc.CallOption) (*types.Void, error)
	// Flush forces any queued up Put and/or Delete operations to execute.
	// If the Store implementation doesn't queue up operations, then this method is a no-op.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// POST /store/flush
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Flush(ctx context.Context, in *types.Void, opts ...grpc.CallOption) (*types.Void, error)
	// Close closes this store object, freeing resources. For persistent store implementations, this does not delete
	// any data in the underlying databases.
	// Close can be called repeatedly on the same store multiple times without causing an error.
	// POST /store/close
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Close(ctx context.Context, in *types.Void, opts ...grpc.CallOption) (*types.Void, error)
}

type storeClient struct {
	cc grpc.ClientConnInterface
}

func NewStoreClient(cc grpc.ClientConnInterface) StoreClient {
	return &storeClient{cc}
}

func (c *storeClient) Put(ctx context.Context, in *StorePutRequest, opts ...grpc.CallOption) (*types.Void, error) {
	out := new(types.Void)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Get(ctx context.Context, in *StoreKeyRequest, opts ...grpc.CallOption) (*StoreGetResponse, error) {
	out := new(StoreGetResponse)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) GetTags(ctx context.Context, in *StoreKeyRequest, opts ...grpc.CallOption) (*StoreTagsResponse, error) {
	out := new(StoreTagsResponse)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/getTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) GetBulk(ctx context.Context, in *StoreBulkKeyRequest, opts ...grpc.CallOption) (*StoreBulkGetResponse, error) {
	out := new(StoreBulkGetResponse)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/getBulk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Query(ctx context.Context, in *StoreQueryRequest, opts ...grpc.CallOption) (Store_QueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &Store_ServiceDesc.Streams[0], "/api.spi.services.Store/query", opts...)
	if err != nil {
		return nil, err
	}
	x := &storeQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Store_QueryClient interface {
	Recv() (*StoreGetResponse, error)
	grpc.ClientStream
}

type storeQueryClient struct {
	grpc.ClientStream
}

func (x *storeQueryClient) Recv() (*StoreGetResponse, error) {
	m := new(StoreGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storeClient) PutBulk(ctx context.Context, in *StoreBulkPutRequest, opts ...grpc.CallOption) (*types.Void, error) {
	out := new(types.Void)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/putBulk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Delete(ctx context.Context, in *StoreKeyRequest, opts ...grpc.CallOption) (*types.Void, error) {
	out := new(types.Void)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Flush(ctx context.Context, in *types.Void, opts ...grpc.CallOption) (*types.Void, error) {
	out := new(types.Void)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/flush", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Close(ctx context.Context, in *types.Void, opts ...grpc.CallOption) (*types.Void, error) {
	out := new(types.Void)
	err := c.cc.Invoke(ctx, "/api.spi.services.Store/close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoreServer is the server API for Store service.
// All implementations must embed UnimplementedStoreServer
// for forward compatibility
type StoreServer interface {
	// Verifies a verifiableCredential and returns a verificationResult in the response body.
	// POST /store
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Put(context.Context, *StorePutRequest) (*types.Void, error)
	// Get fetches the value associated with the given key.
	// If key cannot be found, then an error wrapping ErrDataNotFound will be returned.
	// If key is empty, then an error will be returned.
	// GET /store/{id}
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	Get(context.Context, *StoreKeyRequest) (*StoreGetResponse, error)
	// GetTags fetches all tags associated with the given key.
	// If key cannot be found, then an error wrapping ErrDataNotFound will be returned.
	// If key is empty, then an error will be returned.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// GET /store/{id}
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	GetTags(context.Context, *StoreKeyRequest) (*StoreTagsResponse, error)
	// GetBulk fetches the values associated with the given keys.
	// If no data exists under a given key, then a nil []byte is returned for that value. It is not considered an error.
	// Depending on the implementation, this method may be faster than calling Get for each key individually.
	// If any of the given keys are empty, then an error will be returned.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// GET /store/bulk
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	GetBulk(context.Context, *StoreBulkKeyRequest) (*StoreBulkGetResponse, error)
	// Query returns all data that satisfies the expression. Basic expression format: TagName:TagValue.
	// If TagValue is not provided, then all data associated with the TagName will be returned, regardless of their
	// tag values.
	// At a minimum, a store implementation must be able to support querying with a single basic expression, but a
	// store implementation may also support a more advanced expression format.
	// Advanced expression format: [Criterion1][Operator][Criterion2][Operator]...[CriterionN]. Square brackets are
	// used here for visual clarity. Omit them from the actual expression string.
	// Each Criterion follows the rules for the basic expression format described above.
	// Each operator must be either "&&" or "||" (without quotes). "&&" indicates an AND operator while "||"
	// indicates an OR operator. The order of operations are ANDs followed by ORs.
	// This method also supports a number of QueryOptions. If none are provided, then defaults will be used.
	// If your store contains a large amount of data, then it's recommended calling Provider.SetStoreConfig at some
	// point before calling this method in order to create indexes which will speed up queries.
	// GET /store
	// 200	Credential retrieved
	// 400	Bad Request
	// 401	Not Authorized
	// 410	Gone! There is no data here
	// 418	I'm a teapot - MUST not be returned outside of pre-arranged scenarios between both parties
	// 500	Internal Error
	// 501	Not Implemented
	Query(*StoreQueryRequest, Store_QueryServer) error
	// Batch performs multiple Put and/or Delete operations in order. The Puts and Deletes here follow the same rules
	// as described in the Put and Delete method documentation. The only exception is if the operation makes use of
	// the PutOptions.IsNewKey optimization, in which case an error wrapping an ErrDuplicateKey may be returned if it's
	// enabled and a key is used that already exists in the database.
	// Depending on the implementation, this method may be faster than repeated Put and/or Delete calls.
	// If any of the given keys are empty, or the operations slice is empty or nil, then an error will be returned.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// POST /store/bulk
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	PutBulk(context.Context, *StoreBulkPutRequest) (*types.Void, error)
	// Delete deletes the key + value pair (and all tags) associated with key.
	// If key is empty, then an error will be returned.
	// DELETE /store/{id}
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Delete(context.Context, *StoreKeyRequest) (*types.Void, error)
	// Flush forces any queued up Put and/or Delete operations to execute.
	// If the Store implementation doesn't queue up operations, then this method is a no-op.
	// As of writing, aries-framework-go code does not use this, but it may be useful for custom solutions.
	// POST /store/flush
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Flush(context.Context, *types.Void) (*types.Void, error)
	// Close closes this store object, freeing resources. For persistent store implementations, this does not delete
	// any data in the underlying databases.
	// Close can be called repeatedly on the same store multiple times without causing an error.
	// POST /store/close
	// 200	successfully stored!
	// 400	Invalid or malformed input
	// 413	Payload too large
	// 429	Request rate limit exceeded.
	// 500	error!
	Close(context.Context, *types.Void) (*types.Void, error)
	mustEmbedUnimplementedStoreServer()
}

// UnimplementedStoreServer must be embedded to have forward compatible implementations.
type UnimplementedStoreServer struct {
}

func (UnimplementedStoreServer) Put(context.Context, *StorePutRequest) (*types.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedStoreServer) Get(context.Context, *StoreKeyRequest) (*StoreGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStoreServer) GetTags(context.Context, *StoreKeyRequest) (*StoreTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTags not implemented")
}
func (UnimplementedStoreServer) GetBulk(context.Context, *StoreBulkKeyRequest) (*StoreBulkGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBulk not implemented")
}
func (UnimplementedStoreServer) Query(*StoreQueryRequest, Store_QueryServer) error {
	return status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedStoreServer) PutBulk(context.Context, *StoreBulkPutRequest) (*types.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutBulk not implemented")
}
func (UnimplementedStoreServer) Delete(context.Context, *StoreKeyRequest) (*types.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStoreServer) Flush(context.Context, *types.Void) (*types.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flush not implemented")
}
func (UnimplementedStoreServer) Close(context.Context, *types.Void) (*types.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedStoreServer) mustEmbedUnimplementedStoreServer() {}

// UnsafeStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StoreServer will
// result in compilation errors.
type UnsafeStoreServer interface {
	mustEmbedUnimplementedStoreServer()
}

func RegisterStoreServer(s grpc.ServiceRegistrar, srv StoreServer) {
	s.RegisterService(&Store_ServiceDesc, srv)
}

func _Store_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorePutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Put(ctx, req.(*StorePutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Get(ctx, req.(*StoreKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_GetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).GetTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/getTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).GetTags(ctx, req.(*StoreKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_GetBulk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreBulkKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).GetBulk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/getBulk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).GetBulk(ctx, req.(*StoreBulkKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StoreQueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StoreServer).Query(m, &storeQueryServer{stream})
}

type Store_QueryServer interface {
	Send(*StoreGetResponse) error
	grpc.ServerStream
}

type storeQueryServer struct {
	grpc.ServerStream
}

func (x *storeQueryServer) Send(m *StoreGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Store_PutBulk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreBulkPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).PutBulk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/putBulk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).PutBulk(ctx, req.(*StoreBulkPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Delete(ctx, req.(*StoreKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Flush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Flush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/flush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Flush(ctx, req.(*types.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.spi.services.Store/close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Close(ctx, req.(*types.Void))
	}
	return interceptor(ctx, in, info, handler)
}

// Store_ServiceDesc is the grpc.ServiceDesc for Store service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Store_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.spi.services.Store",
	HandlerType: (*StoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "put",
			Handler:    _Store_Put_Handler,
		},
		{
			MethodName: "get",
			Handler:    _Store_Get_Handler,
		},
		{
			MethodName: "getTags",
			Handler:    _Store_GetTags_Handler,
		},
		{
			MethodName: "getBulk",
			Handler:    _Store_GetBulk_Handler,
		},
		{
			MethodName: "putBulk",
			Handler:    _Store_PutBulk_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _Store_Delete_Handler,
		},
		{
			MethodName: "flush",
			Handler:    _Store_Flush_Handler,
		},
		{
			MethodName: "close",
			Handler:    _Store_Close_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "query",
			Handler:       _Store_Query_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/spi/services/store.proto",
}
